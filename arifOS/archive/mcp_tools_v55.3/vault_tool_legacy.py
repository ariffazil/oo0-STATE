"""
VAULT_TOOL: Postgres-backed Vault999 operations (no stubs).

DESIGN NOTE:
Vault999 records events regardless of approval. Verdict is a field.
VOID entries are still recorded for audit truth.
"""

import logging
from typing import Dict, Any, Optional
from datetime import datetime

from codebase.vault import (
    PersistentVaultLedger,
    should_use_postgres,
)

logger = logging.getLogger("codebase.mcp.tools.vault_tool")


# Authority notice included in all vault responses
AUTHORITY_NOTICE = (
    "This seal is generated by arifOS infrastructure. "
    "ChatGPT/LLM is only the caller, not the authority."
)

# Limits for pagination
_MAX_LIMIT = 200
_DEFAULT_LIMIT = 20


async def _get_ledger() -> PersistentVaultLedger:
    ledger = PersistentVaultLedger()
    await ledger.connect()
    return ledger


def _void(reason: str, **extra: Any) -> Dict[str, Any]:
    """Return a VOID response with authority_notice always included."""
    return {
        "operation": "error",
        "verdict": "VOID",
        "reason": reason,
        "authority_notice": AUTHORITY_NOTICE,
        **extra,
    }


class VaultTool:
    """
    VAULT-999: PostgreSQL-backed immutable ledger and audit trail.
    """

    @staticmethod
    async def execute(
        action: str,
        session_id: Optional[str] = None,
        target: str = "seal",
        payload: Optional[Dict] = None,
        **kwargs,
    ) -> Dict[str, Any]:
        if not should_use_postgres():
            return _void("VAULT_BACKEND must be postgres")

        payload = payload or {}

        if action == "seal":
            return await VaultTool._seal(session_id, payload, target)
        if action == "list":
            return await VaultTool._list(payload)
        if action == "read":
            return await VaultTool._read(session_id, payload)
        if action == "query":
            return await VaultTool._query(payload)
        if action == "verify":
            return await VaultTool._verify()
        if action == "proof":
            return await VaultTool._proof(payload)
        return _void(f"Unknown VAULT action: {action}")

    # ------------------------------------------------------------------ seal

    @staticmethod
    async def _seal(
        session_id: Optional[str], payload: Dict[str, Any], target: str
    ) -> Dict[str, Any]:
        if not session_id:
            return _void("session_id required")
        ledger = await _get_ledger()
        try:
            verdict = payload.get("verdict", "SEAL")
            authority = payload.get("authority", "system")
            seal_data = dict(payload)
            seal_data["target"] = target
            receipt = await ledger.append(
                session_id=session_id,
                verdict=verdict,
                seal_data=seal_data,
                authority=authority,
            )
            return {
                "operation": "sealed",
                "verdict": verdict,
                "sealed": receipt,
                "vault_backend": "postgres",
                "authority_notice": AUTHORITY_NOTICE,
            }
        finally:
            await ledger.close()

    # ------------------------------------------------------------------ list

    @staticmethod
    async def _list(payload: Dict[str, Any]) -> Dict[str, Any]:
        ledger = await _get_ledger()
        try:
            limit = max(1, min(int(payload.get("limit", _DEFAULT_LIMIT)), _MAX_LIMIT))
            cursor = payload.get("cursor")
            if cursor is not None:
                cursor = int(cursor)
                if cursor < 1:
                    return _void("cursor must be a positive integer")
            listing = await ledger.list_entries(cursor=cursor, limit=limit)
            return {
                "operation": "list",
                "verdict": "SEAL",
                **listing,
                "vault_backend": "postgres",
                "authority_notice": AUTHORITY_NOTICE,
            }
        finally:
            await ledger.close()

    # ------------------------------------------------------------------ read

    @staticmethod
    async def _read(
        session_id: Optional[str], payload: Dict[str, Any]
    ) -> Dict[str, Any]:
        ledger = await _get_ledger()
        try:
            seq = payload.get("sequence")
            if seq:
                entry = await ledger.get_entry_by_sequence(int(seq))
                if not entry:
                    return _void("Entry not found")
                return {
                    "operation": "read",
                    "verdict": "SEAL",
                    "entry": entry,
                    "vault_backend": "postgres",
                    "authority_notice": AUTHORITY_NOTICE,
                }
            elif session_id:
                entries = await ledger.get_entries_by_session(session_id)
                if not entries:
                    return _void("No entries found for session")
                return {
                    "operation": "read",
                    "verdict": "SEAL",
                    "entries": entries,
                    "vault_backend": "postgres",
                    "authority_notice": AUTHORITY_NOTICE,
                }
            else:
                return _void("session_id or sequence required")
        finally:
            await ledger.close()

    # ------------------------------------------------------------------ query

    @staticmethod
    async def _query(payload: Dict[str, Any]) -> Dict[str, Any]:
        verdict_filter = payload.get("verdict")
        if not verdict_filter:
            return _void("verdict required")

        start = payload.get("start_time")
        end = payload.get("end_time")

        def _parse(t: Optional[str]) -> Optional[datetime]:
            if not t:
                return None
            return datetime.fromisoformat(t.replace("Z", "+00:00"))

        parsed_start = _parse(start)
        parsed_end = _parse(end)
        if parsed_start and parsed_end and parsed_start > parsed_end:
            return _void("start_time must be <= end_time")

        ledger = await _get_ledger()
        try:
            entries = await ledger.query_by_verdict(
                verdict_filter, parsed_start, parsed_end
            )
            return {
                "operation": "query",
                "verdict": "SEAL",
                "entries": entries,
                "vault_backend": "postgres",
                "authority_notice": AUTHORITY_NOTICE,
            }
        finally:
            await ledger.close()

    # ------------------------------------------------------------------ verify

    @staticmethod
    async def _verify() -> Dict[str, Any]:
        ledger = await _get_ledger()
        try:
            result = await ledger.verify_chain()
            return {
                "operation": "verify",
                "verdict": "SEAL" if result.get("valid") else "VOID",
                **result,
                "vault_backend": "postgres",
                "authority_notice": AUTHORITY_NOTICE,
            }
        finally:
            await ledger.close()

    # ------------------------------------------------------------------ proof

    @staticmethod
    async def _proof(payload: Dict[str, Any]) -> Dict[str, Any]:
        seq = payload.get("sequence")
        if not seq:
            return _void("sequence required")
        ledger = await _get_ledger()
        try:
            proof = await ledger.get_merkle_proof(int(seq))
            if not proof:
                return _void("proof not found")
            return {
                "operation": "proof",
                "verdict": "SEAL",
                **proof,
                "vault_backend": "postgres",
                "authority_notice": AUTHORITY_NOTICE,
            }
        finally:
            await ledger.close()
