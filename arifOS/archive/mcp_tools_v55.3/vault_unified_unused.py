"""
UNIFIED HARDENED VAULT — Single interface for all vault operations.

Consolidates:
- vault_tool.py (original)
- vault_tool_hardened.py (EUREKA filter)
- persistent_ledger_hardened.py (O(log N) Merkle)
- session_ledger.py (filesystem fallback)

Features:
- Automatic backend selection (PostgreSQL → Filesystem)
- EUREKA Sieve filtering (Anomalous Contrast)
- Seal Contract enforcement (VOID expensive, SEAL earned)
- Dual persistence (writes to both backends when available)

Doctrine: Theory of Anomalous Contrast (888_SOUL_VERDICT.md)
"""

from __future__ import annotations

import json
import logging
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union
from uuid import uuid4

# Configure logging
logger = logging.getLogger("codebase.mcp.tools.vault_unified")

# Authority notice included in all vault responses
AUTHORITY_NOTICE = (
    "This seal is generated by arifOS infrastructure. "
    "ChatGPT/LLM is only the caller, not the authority."
)

# Limits for pagination
_MAX_LIMIT = 200
_DEFAULT_LIMIT = 20


# =============================================================================
# Backend Detection
# =============================================================================

def _should_use_postgres() -> bool:
    """Check if PostgreSQL backend is available and configured."""
    backend = os.environ.get("VAULT_BACKEND", "auto").lower()
    if backend == "filesystem":
        return False
    if backend == "postgres":
        return True
    # Auto: check if DSN is available
    return bool(os.environ.get("DATABASE_URL") or os.environ.get("VAULT_POSTGRES_DSN"))


def _asyncpg_available() -> bool:
    """Check if asyncpg is installed."""
    try:
        import asyncpg
        return True
    except ImportError:
        return False


# =============================================================================
# EUREKA Integration
# =============================================================================

async def _run_eureka_sieve(
    query: str,
    response: str,
    trinity_bundle: Dict[str, Any],
    vault_ledger: Optional[Any] = None,
) -> Tuple[str, Dict[str, Any]]:
    """
    Run EUREKA Sieve to determine storage path.
    
    Returns: (target, metadata)
    target: "vault" | "cooling" | None (transient)
    """
    try:
        from codebase.vault.eureka_sieve_hardened import (
            should_seal_to_vault_hardened,
            create_hardened_sieve,
        )
        
        # Create sieve with proper ledger wiring
        should_seal, metadata = await should_seal_to_vault_hardened(
            query=query,
            response=response,
            trinity_bundle=trinity_bundle,
            vault_ledger=vault_ledger,
        )
        
        target = metadata.get("target_ledger")
        return target, metadata
        
    except Exception as e:
        logger.warning(f"EUREKA Sieve failed: {e}. Defaulting to SEAL.")
        # Fail open: default to vault if sieve fails
        return "vault", {
            "eureka_score": 1.0,
            "verdict": "SEAL",
            "error": str(e),
            "fallback": True,
        }


# =============================================================================
# Response Helpers
# =============================================================================

def _void(reason: str, **extra: Any) -> Dict[str, Any]:
    return {
        "operation": "error",
        "verdict": "VOID",
        "reason": reason,
        "authority_notice": AUTHORITY_NOTICE,
        **extra,
    }


def _transient(reason: str, eureka_metadata: Dict, **extra: Any) -> Dict[str, Any]:
    return {
        "operation": "transient",
        "verdict": "TRANSIENT",
        "reason": reason,
        "eureka": eureka_metadata,
        "authority_notice": AUTHORITY_NOTICE,
        "message": "Content not meaningful enough for permanent storage.",
        **extra,
    }


def _sabar(reason: str, eureka_metadata: Dict, **extra: Any) -> Dict[str, Any]:
    return {
        "operation": "cooling",
        "verdict": "SABAR",
        "reason": reason,
        "eureka": eureka_metadata,
        "authority_notice": AUTHORITY_NOTICE,
        "message": "Content in cooling period. Will review after 72h.",
        **extra,
    }


def _sealed(
    receipt: Dict[str, Any],
    backend: str,
    eureka_metadata: Dict,
    dual_write: bool = False,
) -> Dict[str, Any]:
    return {
        "operation": "sealed",
        "verdict": "SEAL",
        "sealed": receipt,
        "vault_backend": backend,
        "eureka": eureka_metadata,
        "dual_write": dual_write,
        "authority_notice": AUTHORITY_NOTICE,
    }


# =============================================================================
# PostgreSQL Backend (Hardened)
# =============================================================================

class PostgresBackend:
    """PostgreSQL backend with full hardening."""
    
    def __init__(self):
        self._ledger = None
    
    async def _get_ledger(self):
        if self._ledger is None:
            from codebase.vault.persistent_ledger_hardened import (
                HardenedPersistentVaultLedger,
                get_hardened_vault_ledger,
            )
            self._ledger = get_hardened_vault_ledger()
            await self._ledger.connect()
        return self._ledger
    
    async def seal(
        self,
        session_id: str,
        verdict: str,
        seal_data: Dict[str, Any],
        authority: str,
    ) -> Dict[str, Any]:
        """Seal to PostgreSQL with contract enforcement."""
        ledger = await self._get_ledger()
        return await ledger.append(
            session_id=session_id,
            verdict=verdict,
            seal_data=seal_data,
            authority=authority,
        )
    
    async def list_entries(self, cursor: Optional[int], limit: int) -> Dict[str, Any]:
        ledger = await self._get_ledger()
        return await ledger.list_entries(cursor=cursor, limit=limit)
    
    async def read(self, session_id: Optional[str], sequence: Optional[int]) -> Optional[Dict]:
        ledger = await self._get_ledger()
        if sequence:
            return await ledger.get_entry_by_sequence(sequence)
        return await ledger.get_entries_by_session(session_id)
    
    async def verify(self) -> Dict[str, Any]:
        ledger = await self._get_ledger()
        return await ledger.verify_chain()


# =============================================================================
# Filesystem Backend (Fallback)
# =============================================================================

class FilesystemBackend:
    """Filesystem backend for when PostgreSQL unavailable."""
    
    def __init__(self):
        from codebase.mcp.session_ledger import get_ledger
        self._ledger = get_ledger()
    
    def seal(
        self,
        session_id: str,
        verdict: str,
        seal_data: Dict[str, Any],
        authority: str,
    ) -> Dict[str, Any]:
        """Seal to filesystem."""
        entry = self._ledger.seal_session(
            session_id=session_id,
            verdict=verdict,
            init_result=seal_data.get("init_result", {}),
            genius_result=seal_data.get("agi_result", {}),
            act_result=seal_data.get("asi_result", {}),
            judge_result=seal_data.get("apex_result", {}),
            telemetry={"eureka": seal_data.get("eureka", {}), "seal_data": seal_data},
            context_summary=seal_data.get("query", "")[:200],
            authority=authority,
        )
        return {
            "sequence_number": entry.sequence,
            "entry_hash": entry.entry_hash,
            "merkle_root": entry.merkle_root,
            "seal_id": entry.seal_id,
            "timestamp": entry.timestamp,
            "vault_backend": "filesystem",
        }
    
    def list_entries(self, cursor: Optional[int], limit: int) -> Dict[str, Any]:
        chain = self._ledger._walk_chain()
        entries = []
        for entry in chain[-limit:]:
            entries.append({
                "sequence": entry.sequence,
                "session_id": entry.session_id,
                "verdict": entry.verdict,
                "timestamp": entry.timestamp,
                "entry_hash": entry.entry_hash,
            })
        return {"entries": entries, "count": len(entries), "has_more": False}
    
    def read(self, session_id: Optional[str], sequence: Optional[int]) -> Optional[Dict]:
        if session_id:
            entry = self._ledger.get_session(session_id)
            if entry:
                return entry.to_dict() if hasattr(entry, "to_dict") else entry
        return None
    
    def verify(self) -> Dict[str, Any]:
        valid, merkle_root = self._ledger.verify_chain()
        return {"valid": valid, "merkle_root": merkle_root}


# =============================================================================
# Unified Vault Tool
# =============================================================================

class UnifiedVaultTool:
    """
    UNIFIED HARDENED VAULT TOOL
    
    Single interface that:
    1. Runs EUREKA Sieve (Anomalous Contrast filter)
    2. Routes to appropriate storage (TRANSIENT/SABAR/VAULT)
    3. Dual-writes to PostgreSQL + Filesystem when available
    4. Enforces seal contract (VOID expensive, SEAL earned)
    """
    
    def __init__(self):
        self._postgres: Optional[PostgresBackend] = None
        self._filesystem: Optional[FilesystemBackend] = None
        self._use_postgres = _should_use_postgres() and _asyncpg_available()
    
    def _get_postgres(self) -> Optional[PostgresBackend]:
        if self._use_postgres and self._postgres is None:
            self._postgres = PostgresBackend()
        return self._postgres
    
    def _get_filesystem(self) -> FilesystemBackend:
        if self._filesystem is None:
            self._filesystem = FilesystemBackend()
        return self._filesystem
    
    # ------------------------------------------------------------------ main entry
    async def execute(
        self,
        action: str,
        session_id: Optional[str] = None,
        target: str = "seal",
        payload: Optional[Dict] = None,
        query: Optional[str] = None,
        response: Optional[str] = None,
        trinity_bundle: Optional[Dict] = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Execute vault action with full hardening.
        
        For seal action:
        1. EUREKA Sieve evaluates anomalous contrast
        2. Routes to TRANSIENT/SABAR/VAULT
        3. Dual-persistence when available
        """
        payload = payload or {}
        
        if action == "seal":
            return await self._seal_hardened(
                session_id=session_id,
                payload=payload,
                target=target,
                query=query,
                response=response,
                trinity_bundle=trinity_bundle,
            )
        elif action == "list":
            return await self._list(payload)
        elif action == "read":
            return await self._read(session_id, payload)
        elif action == "verify":
            return await self._verify()
        else:
            return _void(f"Unknown action: {action}")
    
    # ------------------------------------------------------------------ seal (hardened)
    async def _seal_hardened(
        self,
        session_id: Optional[str],
        payload: Dict[str, Any],
        target: str,
        query: Optional[str],
        response: Optional[str],
        trinity_bundle: Optional[Dict],
    ) -> Dict[str, Any]:
        if not session_id:
            return _void("session_id required")
        
        # Extract data
        query = query or payload.get("query", "")
        response = response or payload.get("response", "")
        trinity_bundle = trinity_bundle or {
            "init": payload.get("init_result", {}),
            "agi": payload.get("agi_result", {}),
            "asi": payload.get("asi_result", {}),
            "apex": payload.get("apex_result", {}),
        }
        
        verdict = payload.get("verdict", "SEAL")
        authority = payload.get("authority", "system")
        
        # 1. EUREKA SIEVE (Anomalous Contrast)
        target_ledger, eureka_metadata = await _run_eureka_sieve(
            query=query,
            response=response,
            trinity_bundle=trinity_bundle,
            vault_ledger=self._get_postgres() if self._use_postgres else None,
        )
        
        eureka_verdict = eureka_metadata.get("verdict", "TRANSIENT")
        eureka_score = eureka_metadata.get("eureka_score", 0.0)
        
        logger.info(
            f"EUREKA Sieve: score={eureka_score:.2f}, verdict={eureka_verdict}, "
            f"target={target_ledger}, query='{query[:50]}...'"
        )
        
        # 2. ROUTE BASED ON EUREKA VERDICT
        
        # TRANSIENT: Don't store
        if eureka_verdict == "TRANSIENT" or target_ledger is None:
            return _transient(
                f"EUREKA Score {eureka_score:.2f} < 0.50: Not meaningful",
                eureka_metadata,
            )
        
        # SABAR: Cooling ledger
        if eureka_verdict == "SABAR":
            return await self._seal_to_cooling(
                session_id=session_id,
                payload=payload,
                eureka_metadata=eureka_metadata,
            )
        
        # SEAL: Permanent vault
        return await self._seal_to_vault(
            session_id=session_id,
            payload=payload,
            verdict=verdict,
            authority=authority,
            eureka_metadata=eureka_metadata,
        )
    
    async def _seal_to_vault(
        self,
        session_id: str,
        payload: Dict[str, Any],
        verdict: str,
        authority: str,
        eureka_metadata: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Seal to permanent vault with dual persistence."""
        # Build enriched seal_data
        seal_data = dict(payload)
        seal_data["eureka"] = eureka_metadata
        
        # Primary: PostgreSQL
        postgres_receipt = None
        if self._use_postgres:
            try:
                pg = self._get_postgres()
                postgres_receipt = await pg.seal(
                    session_id=session_id,
                    verdict=verdict,
                    seal_data=seal_data,
                    authority=authority,
                )
                # Check if contract rejected
                if postgres_receipt.get("contract_violation"):
                    return _void(
                        postgres_receipt.get("reason", "Seal contract violation"),
                        contract_violation=True,
                    )
            except Exception as e:
                logger.error(f"PostgreSQL seal failed: {e}")
        
        # Fallback/Secondary: Filesystem
        fs_receipt = None
        try:
            fs = self._get_filesystem()
            fs_receipt = fs.seal(
                session_id=session_id,
                verdict=verdict,
                seal_data=seal_data,
                authority=authority,
            )
        except Exception as e:
            logger.error(f"Filesystem seal failed: {e}")
        
        # Determine which receipt to return
        if postgres_receipt:
            return _sealed(
                receipt=postgres_receipt,
                backend="postgres",
                eureka_metadata=eureka_metadata,
                dual_write=fs_receipt is not None,
            )
        elif fs_receipt:
            return _sealed(
                receipt=fs_receipt,
                backend="filesystem",
                eureka_metadata=eureka_metadata,
                dual_write=False,
            )
        else:
            return _void("All seal backends failed")
    
    async def _seal_to_cooling(
        self,
        session_id: str,
        payload: Dict[str, Any],
        eureka_metadata: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Seal to cooling ledger."""
        from pathlib import Path
        
        vault_root = Path(os.getenv("VAULT_PATH", "VAULT999"))
        cooling_path = vault_root / "BBB_LEDGER" / "cooling_ledger.jsonl"
        cooling_path.parent.mkdir(parents=True, exist_ok=True)
        
        cooling_entry = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "session_id": session_id,
            "verdict": "SABAR",
            "eureka": eureka_metadata,
            "payload": payload,
            "cooling_hours": 72,
            "review_after": (datetime.now(timezone.utc).timestamp() + 72 * 3600),
        }
        
        with open(cooling_path, "a") as f:
            f.write(json.dumps(cooling_entry) + "\n")
        
        return _sabar(
            f"EUREKA Score {eureka_metadata.get('eureka_score', 0):.2f}: Cooling",
            eureka_metadata,
        )
    
    # ------------------------------------------------------------------ other actions
    async def _list(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        limit = max(1, min(int(payload.get("limit", _DEFAULT_LIMIT)), _MAX_LIMIT))
        cursor = payload.get("cursor")
        
        # Prefer PostgreSQL
        if self._use_postgres:
            try:
                pg = self._get_postgres()
                result = await pg.list_entries(cursor=cursor, limit=limit)
                result["vault_backend"] = "postgres"
                result["authority_notice"] = AUTHORITY_NOTICE
                return result
            except Exception as e:
                logger.warning(f"PostgreSQL list failed: {e}")
        
        # Fallback to filesystem
        fs = self._get_filesystem()
        result = fs.list_entries(cursor=cursor, limit=limit)
        result["vault_backend"] = "filesystem"
        result["authority_notice"] = AUTHORITY_NOTICE
        return result
    
    async def _read(
        self, session_id: Optional[str], payload: Dict[str, Any]
    ) -> Dict[str, Any]:
        seq = payload.get("sequence")
        
        if self._use_postgres:
            try:
                pg = self._get_postgres()
                entry = await pg.read(session_id, seq)
                if entry:
                    return {
                        "operation": "read",
                        "verdict": "SEAL",
                        "entry": entry,
                        "vault_backend": "postgres",
                        "authority_notice": AUTHORITY_NOTICE,
                    }
            except Exception as e:
                logger.warning(f"PostgreSQL read failed: {e}")
        
        fs = self._get_filesystem()
        entry = fs.read(session_id, seq)
        if entry:
            return {
                "operation": "read",
                "verdict": "SEAL",
                "entry": entry,
                "vault_backend": "filesystem",
                "authority_notice": AUTHORITY_NOTICE,
            }
        
        return _void("Entry not found")
    
    async def _verify(self) -> Dict[str, Any]:
        results = {}
        
        if self._use_postgres:
            try:
                pg = self._get_postgres()
                results["postgres"] = await pg.verify()
            except Exception as e:
                results["postgres"] = {"error": str(e)}
        
        fs = self._get_filesystem()
        results["filesystem"] = fs.verify()
        
        # Overall validity
        valid = all(r.get("valid") for r in results.values() if isinstance(r, dict))
        
        return {
            "operation": "verify",
            "verdict": "SEAL" if valid else "VOID",
            "results": results,
            "authority_notice": AUTHORITY_NOTICE,
        }


# =============================================================================
# Singleton Instance
# =============================================================================

_unified_vault: Optional[UnifiedVaultTool] = None


def get_unified_vault() -> UnifiedVaultTool:
    """Get singleton UnifiedVaultTool instance."""
    global _unified_vault
    if _unified_vault is None:
        _unified_vault = UnifiedVaultTool()
    return _unified_vault


# Convenience alias for imports
VaultTool = UnifiedVaultTool
